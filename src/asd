import * as vscode from 'vscode';
import * as path from 'path';
import * as fs from 'fs';
import { NavigatorProvider, NavigatorItem, NavigatorConfig, NavigatorCategoryItem, NavigatorQuickPickItem } from './navigatorView';
import * as os from 'os';

let lastInteractionWasRightClick = false;

async function showContextMenuForItem(item: NavigatorItem) {
    const options = [
        { label: '$(copy) Copy Path', action: 'copy' },
        { label: '$(file-directory) Reveal in Explorer', action: 'reveal' },
        { label: '$(edit) Edit', action: 'edit' },
        { label: '$(edit) Edit Label', action: 'editLabel' },
        { label: '$(trash) Delete', action: 'delete' }
    ];

    const selected = await vscode.window.showQuickPick(options.map(x => x.label), { placeHolder: `Action for ${item.label}` });

    if (selected) {
        const action = options.find(x => x.label === selected)?.action;
        switch (action) {
            case 'copy':
                if (item.filePath) {
                    if (item.type === 'file') {
                        await vscode.commands.executeCommand('ocrmnavigator.copyPath');
                        await vscode.env.clipboard.writeText(String(item.filePath));
                        return;
                    }
                    if (item.type === 'url') {
                        if (item.path) {
                            await vscode.env.clipboard.writeText(item.path);
                            await vscode.commands.executeCommand('ocrmnavigator.copyPath');
                            return;
                        }
                    }
                    if (item.type === 'command') {
                        if (item.path) {
                            await vscode.env.clipboard.writeText(item.path);
                        }
                        return;
                    }
                    if (item.type === 'folder') {
                        return;
                    }
                    if (item.type === 'md') {
                        await vscode.env.clipboard.writeText(String(item));
                        return;
                    }
                    if (item.type === 'snippet') {
                        await vscode.env.clipboard.writeText(String(item.body));
                        return;
                    }
                    if (item.type === 'powershellCommand') {
                        await vscode.env.clipboard.writeText(String(item.path));
                        return;
                    }
                }
                break;
            case 'reveal':
                if (item.filePath) {
                    vscode.commands.executeCommand('revealFileInOS', vscode.Uri.file(item.filePath));
                }
                break;
            case 'edit':
                // Implement edit
                if (item.filePath) {
                    if (item.type === 'file') {
                        await vscode.commands.executeCommand('ocrmnavigator.editFileLabel');
                        return;
                    }
                    if (item.type === 'url') {
                        await vscode.commands.executeCommand('ocrmnavigator.editWebUrl');
                        return;
                    }
                    if (item.type === 'command') {
                        vscode.commands.executeCommand('ocrmnavigator.editCommand');
                        return;
                    }
                    if (item.type === 'folder') {
                        vscode.commands.executeCommand('ocrmnavigator.renameCategory');
                        return;
                    }
                    if (item.type === 'md') {
                        vscode.commands.executeCommand('ocrmnavigator.editMD');
                        return;
                    }
                    if (item.type === 'snippet') {
                        vscode.commands.executeCommand('ocrmnavigator.editSnippet');
                        return;
                    }
                    if (item.type === 'powershellCommand') {
                        vscode.commands.executeCommand('ocrmnavigator.editWebUrl');
                        return;
                    }
                }
                break;
            case 'editLabel':
                // Implement edit
                if (item.filePath) {
                    if (item.type === 'file') {
                        await vscode.commands.executeCommand('ocrmnavigator.editFileLabel');
                        return;
                    }
                    if (item.type === 'url') {
                        await vscode.commands.executeCommand('ocrmnavigator.editWebUrl');
                        return;
                    }
                    if (item.type === 'command') {
                        vscode.commands.executeCommand('ocrmnavigator.editCommand');
                        return;
                    }
                    if (item.type === 'folder') {
                        vscode.commands.executeCommand('ocrmnavigator.renameCategory');
                        return;
                    }
                    if (item.type === 'md') {
                        vscode.commands.executeCommand('ocrmnavigator.editMDLabel');
                        return;
                    }
                    if (item.type === 'snippet') {
                        vscode.commands.executeCommand('ocrmnavigator.editSnippet');
                        return;
                    }
                    if (item.type === 'powershellCommand') {
                        vscode.commands.executeCommand('ocrmnavigator.editWebUrl');
                        return;
                    }
                }
                break;
            case 'delete':
                if (item.filePath) {
                    if (item.type === 'file') {
                        await vscode.commands.executeCommand('ocrmnavigator.deleteItem');
                        return;
                    }
                    if (item.type === 'command') {
                        await vscode.commands.executeCommand('ocrmnavigator.deleteItem');
                        return;
                    } if (item.type === 'folder') {
                        await vscode.commands.executeCommand('ocrmnavigator.deleteCategory');
                        return;
                    } if (item.type === 'md') {
                        await vscode.commands.executeCommand('ocrmnavigator.removeMD');
                        return;
                    } if (item.type === 'snippet') {
                        await vscode.commands.executeCommand('ocrmnavigator.deleteSnippet');
                        return;
                    } if (item.type === 'command') {
                        vscode.commands.executeCommand('ocrmnavigator.removeCommand');
                        return;
                    } if (item.type === 'powershellCommand') {
                        await vscode.commands.executeCommand('ocrmnavigator.removeCommand');
                        return;
                    }
                }
                // Implement delete
                break;
        }
    }
}
async function showContextMenu(item: NavigatorItem) {
    return showContextMenuForItem(item);
}

export function activate(context: vscode.ExtensionContext) {
    console.log('Extension activating...');

    // Verify workspace is open
    const workspaceRoot = vscode.workspace.workspaceFolders?.[0]?.uri.fsPath;
    if (!workspaceRoot) {
        vscode.window.showErrorMessage('Please open a workspace folder first');
        return;
    }
    console.log('Workspace root:', workspaceRoot);

    // Ensure storage directory exists
    const storagePath = context.globalStorageUri.fsPath;
    if (!fs.existsSync(storagePath)) {
        fs.mkdirSync(storagePath, { recursive: true });
    }

    // Set up config file path
    const configPath = path.join(storagePath, 'navigator-config.json');
    console.log('Configuration path:', configPath);

    // Create default config if needed
    if (!fs.existsSync(configPath)) {
        const defaultConfig = {
            "categories": [
                {
                    "label": "CMDS",
                    "type": "folder",
                    "expanded": true,
                    "items": [
                        {
                            "label": "VSCode Commands Reference",
                            "path": "command:ocrmnavigator.showCommandsReference",
                            "type": "command"
                        },
                        {
                            "label": "Formatting",
                            "type": "folder",
                            "items": [
                                {
                                    "label": "Format Document",
                                    "cmd": "editor.action.formatDocument",
                                    "type": "command"
                                }
                            ]
                        },
                        {
                            "label": "Folding",
                            "type": "folder",
                            "items": [
                                {
                                    "label": "Fold Level 1",
                                    "cmd": "editor.foldLevel1",
                                    "type": "command"
                                }
                            ]
                        }
                    ]
                },
                {
                    "label": "FILES",
                    "expanded": true,
                    "items": [
                        {
                            "label": "Admin Dashboard",
                            "path": "apps/app/app/routes/portal/$dept/settings/general.tsx",
                            "type": "file"
                        },
                        {
                            "label": "Client Dashboard",
                            "path": "apps/app/app/routes/client/portal/sales/dashboard.tsx",
                            "type": "file"
                        }
                    ]
                },
                {
                    "label": "RELATED",
                    "expanded": false,
                    "items": [
                        {
                            "label": "client.website",
                            "path": "apps/app/app/routes/dealer/client/home.tsx",
                            "type": "file"
                        }
                    ]
                },
                {
                    "label": "COMPONENTS",
                    "expanded": false,
                    "items": [
                        {
                            "label": "app.sidebar",
                            "path": "apps/app/app/routes/__component/appSidebar.tsx",
                            "type": "file"
                        }
                    ]
                },
                {
                    "label": "UTILS",
                    "expanded": false,
                    "items": [
                        {
                            "label": "loader.server",
                            "path": "apps/app/app/utils/loader.server.tsx",
                            "type": "file"
                        }
                    ]
                },
                // copy snippet to clipboard when clicked
                {
                    "label": "SNIPPETS",
                    "expanded": false,
                    "items": [
                        {
                            "label": "loader.server",
                            "path": "apps/app/app/utils/loader.server.tsx"
                        }
                    ]
                },
                {
                    "label": "WEB",
                    "expanded": true,
                    "items": [
                        {
                            "label": "localhost/somewhere",
                            "path": "http://localhost:3000",
                            "type": "url"
                        },
                        {
                            "label": "Github",
                            "path": "https://www.github.com",
                            "type": "url"
                        },
                        {
                            "label": "Vercel Dashboard",
                            "path": "https://vercel.com/user",
                            "type": "url"
                        }
                    ]
                },
                {
                    "label": "MD",
                    "expanded": false,
                    "items": [
                        {
                            "label": "Admin Dashboard",
                            "path": "apps/app/app/routes/portal/$dept/settings/general.tsx",
                            "type": "file"
                        },
                        {
                            "label": "Client Dashboard",
                            "path": "apps/app/app/routes/client/portal/sales/dashboard.tsx",
                            "type": "file"
                        }
                    ]
                },
                {
                    "label": "TODO",
                    "expanded": false,
                    "items": [
                        {
                            "label": "Admin Dashboard",
                            "path": "apps/app/app/routes/portal/$dept/settings/general.tsx",
                            "type": "file"
                        },
                        {
                            "label": "Client Dashboard",
                            "path": "apps/app/app/routes/client/portal/sales/dashboard.tsx",
                            "type": "file"
                        }
                    ]
                }
            ]
        };
        fs.writeFileSync(configPath, JSON.stringify(defaultConfig, null, 2));
    }

    // Initialize provider
    const navigatorProvider = new NavigatorProvider(workspaceRoot, configPath);

    // Register tree view
    const view = vscode.window.createTreeView('ocrmnavigatorNavigator', {
        treeDataProvider: navigatorProvider,
        showCollapseAll: true
    });

    // helper function for snippets
    const SNIPPETS_TSX_DIR = path.join('.vscode', 'snippets-tsx');
    const SNIPPETS_DIR = path.join('.vscode');
    interface SnippetDefinition {
        prefix: string;
        body: string[];
        description: string;
        scope: string;
    }

    interface SnippetCollection {
        [name: string]: SnippetDefinition;
    }

    async function processSnippetFiles(workspaceRoot: string) {
        const tsxSnippetsPath = path.join(workspaceRoot, SNIPPETS_TSX_DIR);
        const snippetsPath = path.join(workspaceRoot, SNIPPETS_DIR);
        const snippetFilePath = path.join(snippetsPath, 'ocrmnavigator.code-snippets');

        // Create directories if they don't exist
        if (!fs.existsSync(tsxSnippetsPath)) {
            fs.mkdirSync(tsxSnippetsPath, { recursive: true });
        }
        if (!fs.existsSync(snippetsPath)) {
            fs.mkdirSync(snippetsPath, { recursive: true });
        }

        // Load existing snippets if file exists
        let existingSnippets: SnippetCollection = {};
        if (fs.existsSync(snippetFilePath)) {
            try {
                existingSnippets = JSON.parse(fs.readFileSync(snippetFilePath, 'utf8')) as SnippetCollection;
            } catch (e) {
                console.error('Error parsing existing snippets:', e);
                existingSnippets = {};
            }
        }

        // Process all .tsx snippet files
        const tsxFiles = fs.readdirSync(tsxSnippetsPath)
            .filter(file => file.endsWith('.snippet.tsx'));

        let changed = false;
        for (const tsxFile of tsxFiles) {
            const tsxFilePath = path.join(tsxSnippetsPath, tsxFile);
            const snippetName = path.basename(tsxFile, '.snippet.tsx');

            try {
                // Read TSX file content
                const content = fs.readFileSync(tsxFilePath, 'utf8');
                const lines = content.split('\n').filter(line => line.trim() !== '');

                if (lines.length < 1) {
                    vscode.window.showWarningMessage(`Snippet ${tsxFile} needs at least 1 line (prefix)`);
                    continue;
                }

                // Extract prefix (first line) and body (remaining lines)
                const prefix = lines[0].trim();
                const body = lines.slice(1).join('\n');

                // Add/update the snippet in our collection
                existingSnippets[snippetName] = {
                    prefix,
                    body: body.split('\n'),
                    description: `Custom snippet from ${tsxFile}`,
                    scope: "typescript,typescriptreact"
                };

                changed = true;

                // Delete the processed TSX file
                fs.unlinkSync(tsxFilePath);

            } catch (error) {
                vscode.window.showErrorMessage(
                    `Failed to process ${tsxFile}: ${error instanceof Error ? error.message : String(error)}`
                );
            }
        }

        // Only write if we made changes
        if (changed) {
            fs.writeFileSync(snippetFilePath, JSON.stringify(existingSnippets, null, 2));
        }
    }
    function setupFileWatcher(workspaceRoot: string) {
        const tsxSnippetsPath = path.join(workspaceRoot, SNIPPETS_TSX_DIR);
        const watcher = vscode.workspace.createFileSystemWatcher(
            new vscode.RelativePattern(tsxSnippetsPath, '*.snippet.tsx')
        );

        watcher.onDidChange(uri => processSnippetFiles(workspaceRoot));
        watcher.onDidCreate(uri => processSnippetFiles(workspaceRoot));
        watcher.onDidDelete(uri => processSnippetFiles(workspaceRoot));

        return watcher;
    }
      // Initial processing
      processSnippetFiles(workspaceRoot);
      // Set up watcher
      const watcher = setupFileWatcher(workspaceRoot);
  
  
      let itemToMove: NavigatorItem | null = null;
      function executeTerminalCommand(command: string): void {
          const terminal = vscode.window.createTerminal('Navigator Command');
          terminal.show();
          // Add a small delay to ensure the terminal is ready
          setTimeout(() => {
              terminal.sendText(command);
          }, 500);
      }
      const quickPick = vscode.window.createQuickPick();
      const options = [
          { label: '$(copy) Copy Path', action: 'copy' },
          { label: '$(file-directory) Reveal in Explorer', action: 'reveal' },
          { label: '$(edit) Edit', action: 'edit' },
          { label: '$(edit) Edit Label', action: 'editLabel' },
          { label: '$(trash) Delete', action: 'delete' }
      ];
      // Add right-click action button to each item
      quickPick.items = options.map(item => ({
          ...item,
          buttons: [{
              iconPath: new vscode.ThemeIcon('ellipsis'),
              tooltip: 'More actions'
          }]
      }));
  
      // Handle button clicks (right-click alternative)
      quickPick.onDidTriggerItemButton(e => {
          showContextMenu(e.item.data as NavigatorItem);
      });
  
      // Helper function for folder expansion
      async function updateFolderExpansion(item: NavigatorItem, expanded: boolean) {
          try {
              if (!item || item.type !== 'folder') {
                  vscode.window.showErrorMessage('Please select a folder first');
                  return;
              }
  
              const configContent = fs.readFileSync(configPath, 'utf8');
              const config = JSON.parse(configContent) as NavigatorConfig;
  
              // Recursive function to find and update the folder
              const updateFolder = (items: NavigatorItem[]): boolean => {
                  return items.some(category => {
                      if (category.label === item.label && category.type === 'folder') {
                          (category as NavigatorCategoryItem).expanded = expanded;
                          return true;
                      }
                      if (category.type === 'folder' && category.children) {
                          return updateFolder(category.children);
                      }
                      return false;
                  });
              };
  
              if (updateFolder(config.categories)) {
                  fs.writeFileSync(configPath, JSON.stringify(config, null, 2), 'utf8');
                  vscode.commands.executeCommand('ocrmnavigator.refresh');
                  const action = expanded ? 'expanded' : 'collapsed';
                  vscode.window.showInformationMessage(`Folder "${item.label}" ${action}`);
              } else {
                  vscode.window.showErrorMessage('Folder not found in config');
              }
          } catch (error) {
              vscode.window.showErrorMessage(
                  `Failed to update folder: ${error instanceof Error ? error.message : String(error)}`
              );
          }
      };
      // Function to select or create folder
      const selectFolder = async (config: NavigatorConfig): Promise<{ targetItems: NavigatorItem[], location: string } | undefined> => {
          // Get all available folders
          const allFolders: { label: string, items: NavigatorItem[] }[] = [];
  
          const collectFolders = (items: NavigatorItem[], path: string): void => {
              items.forEach(item => {
                  if (item.type === 'folder') {
                      const fullPath = `${path}/${item.label}`;
                      allFolders.push({
                          label: fullPath,
                          items: (item as NavigatorCategoryItem).items || []
                      });
                      if ((item as NavigatorCategoryItem).items) {
                          collectFolders((item as NavigatorCategoryItem).items, fullPath);
                      }
                  }
              });
          };
  
          collectFolders(config.categories, '');
  
          // Define proper types for QuickPick options
          type FolderOption = {
              label: string;
              description: string;
              folder?: { label: string; items: NavigatorItem[] };
          };
  
          // Prepare quick pick options
          const options: FolderOption[] = [
              {
                  label: 'Create new folder',
                  description: 'Add a new top-level folder'
              },
              ...allFolders.map(folder => ({
                  label: folder.label,
                  description: `${folder.items.length} items`,
                  folder: folder // Explicitly include folder property
              }))
          ];
  
          const selected = await vscode.window.showQuickPick(options, {
              placeHolder: 'Select a folder or create new'
          });
  
          if (!selected) return undefined;
  
          if (selected.label === 'Create new folder') {
              const folderName = await vscode.window.showInputBox({
                  prompt: 'Enter new folder name',
                  validateInput: value => {
                      if (!value.trim()) return 'Folder name cannot be empty';
                      return null;
                  }
              });
  
              if (!folderName) return undefined;
  
              const newFolder: NavigatorCategoryItem = {
                  label: folderName,
                  type: 'folder',
                  expanded: true,
                  items: [],
                  collapsibleState: vscode.TreeItemCollapsibleState.Collapsed,
                  filePath: ''
              };
  
              config.categories.push(newFolder);
              return {
                  targetItems: newFolder.items,
                  location: folderName
              };
          } else {
              // Type guard to ensure folder exists
              if (!selected.folder) {
                  vscode.window.showErrorMessage('Invalid folder selection');
                  return undefined;
              }
  
              // Ask if they want to add directly or create subfolder
              const action = await vscode.window.showQuickPick([
                  'Add directly here',
                  'Create subfolder'
              ], {
                  placeHolder: `Add to ${selected.label} or create subfolder?`
              });
  
              if (!action) return undefined;
  
              if (action === 'Create subfolder') {
                  const subfolderName = await vscode.window.showInputBox({
                      prompt: 'Enter subfolder name',
                      validateInput: value => {
                          if (!value.trim()) return 'Subfolder name cannot be empty';
                          return null;
                      }
                  });
  
                  if (!subfolderName) return undefined;
  
                  const newSubfolder: NavigatorCategoryItem = {
                      label: subfolderName,
                      type: 'folder',
                      expanded: true,
                      items: [],
                      collapsibleState: vscode.TreeItemCollapsibleState.Collapsed,
                      filePath: ''
                  };
  
                  selected.folder.items.push(newSubfolder);
                  return {
                      targetItems: newSubfolder.items,
                      location: `${selected.label}/${subfolderName}`
                  };
              } else {
                  return {
                      targetItems: selected.folder.items,
                      location: selected.label
                  };
              }
          }
      };
      // Function to generate the HTML content for our webview
      function getCommandsWebviewContent() {
          const iadded = [
              ["foldLevel1", "editor.foldLevel1"],
              ["foldLevel2", "editor.foldLevel2"],
              ["foldLevel3", "editor.foldLevel3"],
              ["foldLevel4", "editor.foldLevel4"],
              ["foldLevel5", "editor.foldLevel5"],
              ["foldLevel6", "editor.foldLevel6"],
              ["foldLevel7", "editor.foldLevel7"],
              ["unfoldAll", "editor.unfoldAll"],
  
          ]
          // Define our commands array  // Helper function to find an item in the configuration
    function findItemInConfig(config: NavigatorConfig, item: NavigatorItem): {
        parentCategory: NavigatorCategoryItem | null,
        itemIndex: number,
        itemsArray: any[]
    } | null {
        // Search through all categories and their nested items
        for (const category of config.categories) {
            // Check if the item is directly in this category
            const categoryItemIndex = category.items.findIndex(fileItem =>
                fileItem.label === item.label &&
                (fileItem.path === item.filePath || fileItem.filePath === item.filePath)
            );

            if (categoryItemIndex !== -1) {
                return {
                    parentCategory: category,
                    itemIndex: categoryItemIndex,
                    itemsArray: category.items
                };
            }

            // Search through the category's subfolders
            for (let i = 0; i < category.items.length; i++) {
                const subItem = category.items[i];

                if (subItem.type === 'folder' && 'items' in subItem) {
                    const folderItem = subItem as NavigatorCategoryItem;

                    // Search in this folder's items
                    const subIndex = folderItem.items.findIndex(fileItem =>
                        fileItem.label === item.label &&
                        (fileItem.path === item.filePath || fileItem.filePath === item.filePath)
                    );

                    if (subIndex !== -1) {
                        return {
                            parentCategory: folderItem,
                            itemIndex: subIndex,
                            itemsArray: folderItem.items
                        };
                    }

                    // Recursively search deeper (for nested folders)
                    const deepResult = searchNestedFolder(folderItem, item);
                    if (deepResult) {
                        return deepResult;
                    }
                }
            }
        }

        return null;
    }

    // Helper function to recursively search through nested folders
    function searchNestedFolder(folder: NavigatorCategoryItem, item: NavigatorItem): {
        parentCategory: NavigatorCategoryItem,
        itemIndex: number,
        itemsArray: any[]
    } | null {
        if (!folder.items) {
            return null;
        }

        // Search for the item in this folder's items
        const itemIndex = folder.items.findIndex(fileItem =>
            fileItem.label === item.label &&
            (fileItem.path === item.filePath || fileItem.filePath === item.filePath)
        );

        if (itemIndex !== -1) {
            return {
                parentCategory: folder,
                itemIndex: itemIndex,
                itemsArray: folder.items
            };
        }

        // Search through any nested folders
        for (const subItem of folder.items) {
            if (subItem.type === 'folder' && 'items' in subItem) {
                const nestedFolder = subItem as NavigatorCategoryItem;
                const result = searchNestedFolder(nestedFolder, item);
                if (result) {
                    return result;
                }
            }
        }

        return null;
    }
    // In your extension activation
    const actionBtn = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Right);
    actionBtn.text = '$(list-flat) Actions';
    actionBtn.command = 'ocrmnavigator.showActionsMenu';
    actionBtn.tooltip = 'Show OCRMNavigator Actions';
    actionBtn.show();

    context.subscriptions.push(vscode.commands.registerCommand('ocrmnavigator.showActionsMenu', async () => {
        const items = [
            { label: '$(add) Add Folder', command: 'ocrmnavigator.addCategory' },
            { label: '$(terminal) Add Command', command: 'ocrmnavigator.addCommandToCategory' },
            { label: '$(markdown) Create MD', command: 'ocrmnavigator.createMD' },
            { label: '$(markdown) Create MD W Cheat Sheet', command: 'ocrmnavigator.createMD' },
            { label: '$(link) Add URL', command: 'ocrmnavigator.addUrlToNavigator' },
            { label: '$(book) MD Cheat Sheet', command: 'ocrmnavigator.viewMarkdownGuide' },
            { label: '$(book) VSCode CMD Cheat Sheet', command: 'ocrmnavigator.showCommandsReference' },
            { label: '$(gear) Edit Config', command: 'ocrmnavigator.editConfig' },
            { label: '$(arrow-up) Import Config', command: 'ocrmnavigator.importConfig' },
            { label: '$(arrow-down) Export Config', command: 'ocrmnavigator.showCommanexportConfigdsReference' },
            { label: '$(refresh) Refresh', command: 'ocrmnavigator.refresh' }
        ];

        const selected = await vscode.window.showQuickPick(items, {
            placeHolder: 'Select an action...'
        });

        if (selected) {
            vscode.commands.executeCommand(selected.command);
        }
    }))


    // Add this to your activate function
    // Create the search container with input and checkbox
    const searchContainer = vscode.window.createWebviewPanel(
        'ocrmnavigatorSearch',
        'Search',
        vscode.ViewColumn.One,
        {
            enableScripts: true,
            retainContextWhenHidden: true
        }
    );

    // Hide the panel initially - we'll use our own UI
    searchContainer.dispose();

    context.subscriptions.push(
        vscode.commands.registerCommand('ocrmnavigator.search', () => {
            const quickPick = vscode.window.createQuickPick<NavigatorQuickPickItem>();
            quickPick.title = "OCRM Navigator Search";
            quickPick.placeholder = 'Type to search...';
            quickPick.ignoreFocusOut = true;

            // Add toggle item
            const toggleItem = {
                label: "$(file) Search in file contents",
                description: "Toggle this option",
                picked: navigatorProvider.getSearchInFileContents(),
                alwaysShow: true
            };

            // Initial items
            quickPick.items = [toggleItem];

            let searchTimeout: NodeJS.Timeout;
            quickPick.onDidChangeValue(async (text) => {
                clearTimeout(searchTimeout);

                if (text) {
                    searchTimeout = setTimeout(async () => {
                        quickPick.busy = true;
                        try {
                            const results = await navigatorProvider.getQuickPickSearchResults(text);

                            // Transform results with context menu buttons
                            const quickPickItems: NavigatorQuickPickItem[] = results.map(item => ({
                                label: item.label,
                                description: item.description,
                                detail: item.filePath,
                                data: item,
                                buttons: [{
                                    iconPath: new vscode.ThemeIcon('ellipsis'),
                                    tooltip: 'More actions'
                                }]
                            }));

                            quickPick.items = [toggleItem, ...quickPickItems];

                        } catch (error) {
                            console.error("Search failed:", error);
                        } finally {
                            quickPick.busy = false;
                        }
                    }, 300);
                } else {
                    quickPick.items = [toggleItem];
                }
            });

            // Handle item button clicks (context menu)
            quickPick.onDidTriggerItemButton(e => {
                showContextMenu(e.item.data);
            });

            // Handle item selection (left click/enter)
            quickPick.onDidAccept(() => {
                const selected = quickPick.activeItems[0];
                if (selected && 'data' in selected) {
                    quickPick.hide();
                    navigatorProvider.handleSearchResultSelection(selected.data);
                }
            });

            quickPick.show();
        })
    );
    // Add search button to the view title
    context.subscriptions.push(
        vscode.window.registerTreeDataProvider('ocrmnavigatorNavigator', navigatorProvider)
    );

    context.subscriptions.push(
        vscode.window.createTreeView('ocrmnavigatorNavigator', {
            treeDataProvider: navigatorProvider,
            showCollapseAll: true
        })
    );


    view.title = "F/F Navigator";
    setTimeout(() => {
        if (!view.visible) {
            vscode.commands.executeCommand('ocrmnavigatorNavigator.focus');
        }
    }, 1000);
}